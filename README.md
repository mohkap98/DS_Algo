# Data Structures & Algorithms (DSA) Guide

Data Structures and Algorithms (DSA) form the foundation of efficient programming. Mastering DSA helps in problem-solving, competitive programming, and system design.

## üìå Key Data Structures

### 1Ô∏è‚É£ Arrays & Strings
- **Fixed-size collections** of elements.
- **Operations**: Access (O(1)), Search (O(n)), Insert/Delete (O(n)).
- **Common Problems**: Sliding window, two-pointer techniques, prefix sum.

### 2Ô∏è‚É£ Linked Lists
- **Types**: Singly, Doubly, Circular.
- **Operations**: Insert/Delete (O(1) at head/tail), Search (O(n)).
- **Use Cases**: Dynamic memory allocation, LRU Cache.

### 3Ô∏è‚É£ Stacks & Queues
- **Stack (LIFO)**: Used in recursion, backtracking, expression evaluation.
- **Queue (FIFO)**: Used in BFS, scheduling.
- **Variants**: Priority Queue, Deque, Monotonic Queue.

### 4Ô∏è‚É£ Hashing & Hash Tables
- **Hash functions**: Convert keys to indices.
- **Collision Handling**: Chaining, Open Addressing.
- **Use Cases**: Caching, Dictionaries, Sets.

### 5Ô∏è‚É£ Trees
- **Binary Tree**: Parent-child hierarchy.
- **Binary Search Tree (BST)**: O(log n) search/insert.
- **Balanced Trees**: AVL, Red-Black, B-Trees.
- **Trie**: Used in prefix-based searching.

### 6Ô∏è‚É£ Graphs
- **Representation**: Adjacency List, Adjacency Matrix.
- **Traversal**: BFS (Queue), DFS (Stack/Recursion).
- **Algorithms**: Dijkstra, Floyd-Warshall, Kruskal, Prim.

### 7Ô∏è‚É£ Heaps & Priority Queues
- **Min Heap / Max Heap**: Efficient top-k operations.
- **Use Cases**: Dijkstra‚Äôs Algorithm, scheduling.

## üî• Key Algorithms

### 1Ô∏è‚É£ Sorting
- **Comparison-based**: QuickSort, MergeSort, HeapSort (O(n log n)).
- **Non-comparison-based**: CountingSort, RadixSort, BucketSort (O(n)).

### 2Ô∏è‚É£ Searching
- **Binary Search (O(log n))**: Works on sorted data.
- **Interpolation & Exponential Search**: Optimized variants.

### 3Ô∏è‚É£ Recursion & Backtracking
- **Divide & Conquer**: Merge Sort, Quick Sort.
- **Backtracking**: N-Queens, Sudoku Solver.

### 4Ô∏è‚É£ Dynamic Programming (DP)
- **Memoization (Top-Down)**: Recursive with caching.
- **Tabulation (Bottom-Up)**: Iterative with array.
- **Problems**: Knapsack, LCS, LIS, Matrix Chain Multiplication.

### 5Ô∏è‚É£ Greedy Algorithms
- **Local optimal -> Global optimal**.
- **Examples**: Huffman Coding, Activity Selection, Kruskal‚Äôs Algorithm.

### 6Ô∏è‚É£ Graph Algorithms
- **Shortest Path**: Dijkstra, Bellman-Ford, Floyd-Warshall.
- **Minimum Spanning Tree**: Kruskal, Prim.
- **Cycle Detection**: Union-Find, DFS.

## üéØ Tips & Tricks
- Optimize brute force using **mathematical insights**.
- Use **prefix sums** to solve range sum problems efficiently.
- **Sliding window & two-pointer** techniques for array problems.
- Master **bit manipulation** for low-level optimizations.
- **Binary search on answer** for optimization problems.

## üìö Resources for Learning
- **Books**:
  - "Introduction to Algorithms" - Cormen, Leiserson, Rivest, Stein.
  - "Cracking the Coding Interview" - Gayle Laakmann McDowell.
  - "Grokking Algorithms" - Aditya Bhargava.
- **Online Courses**:
  - Coursera: Algorithms by Stanford.
  - Udacity: Data Structures & Algorithms Nanodegree.
  - MIT OpenCourseWare: Introduction to Algorithms.

üöÄ Mastering DSA is key to becoming a great problem solver!

